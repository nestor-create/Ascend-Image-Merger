mergeBtn.onclick = async () => {
  warnEl.textContent = '';

  const gap = Math.max(0, parseInt(gapEl.value || '0', 10));
  const bg = safeParseColor((bgEl.value || '#ffffff').trim());

  const MIN_HD = 1920;   // minimum HD width
  const MAX_4K = 3840;   // maximum width cap

  // Determine target width intelligently
  const widest = Math.max(...items.map(i => i.w));

  let targetWidth;
  if (widest < MIN_HD) {
    targetWidth = MIN_HD;        // upscale small images to HD
  } else if (widest > MAX_4K) {
    targetWidth = MAX_4K;        // downscale huge images to 4K
  } else {
    targetWidth = widest;        // keep natural size
  }

  // Scale everything to same width
  const planned = items.map(it => {
    const scale = targetWidth / it.w;
    return {
      ...it,
      dw: Math.round(it.w * scale),
      dh: Math.round(it.h * scale),
      scale
    };
  });

  const outW = targetWidth;
  const outH = planned.reduce((sum, p) => sum + p.dh, 0) + gap * (planned.length - 1);

  canvas.width = outW;
  canvas.height = outH;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,outW,outH);

  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';

  let y = 0;
  for (const p of planned) {
    ctx.drawImage(p.img, 0, Math.round(y), p.dw, p.dh);
    y += p.dh + gap;
  }

  if (lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
  const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
  if (!blob) {
    warnEl.textContent = 'Export failed.';
    return;
  }

  lastBlobUrl = URL.createObjectURL(blob);
  openBtn.disabled = false;
  copyBtn.disabled = false;

  const mpFinal = (canvas.width * canvas.height) / 1_000_000;
  statusEl.textContent = `Merged: ${canvas.width} × ${canvas.height}px (${mpFinal.toFixed(1)} MP) — HD Optimized`;
};